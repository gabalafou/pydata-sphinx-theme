@use "sass:map";
@use "sass:meta";
@use "sass:string";

:root {
  // Add theme colours to the html root element
  @each $group-color, $color in $color-palette {
    @each $color-name, $definition in $color {
      --pst-#{$group-color}-#{$color-name}: #{$definition};
    }
  }
}

/*******************************************************************************
* write the color rules for each theme (light/dark)
*/

/* NOTE:
 * Mixins enable us to reuse the same definitions for the different modes
 * https://sass-lang.com/documentation/at-rules/mixin
 * #{something} inserts a variable into a CSS selector or property name
 * https://sass-lang.com/documentation/interpolation
 */
@mixin theme-colors($mode) {
  // check if this color is defined differently for light/dark
  @each $col-name, $definition in $pst-semantic-colors {
    @if meta.type-of($definition) == map {
      @each $key, $val in $definition {
        @if string.index($key, $mode) {
          // since now we define the bg colours in the semantic colours and not
          // by changing opacity, we need to check if the key contains bg and the
          // correct mode (light/dark)
          @if string.index($key, "bg") {
            --pst-color-#{$col-name}-bg: #{$val};
          } @else {
            --pst-color-#{$col-name}: #{$val};
          }
        }
      }
    } @else {
      --pst-color-#{$col-name}: #{$definition};
    }
  }

  // assign the "duplicate" colors (ones that just reference other variables)
  & {
    // From 0.16.1, the preferred variable for headings is --pst-color-heading
    // if you have --pst-heading-color, this variable will be used, otherwise the default
    // --pst-color-heading will be used
    --pst-color-heading: var(--pst-color-text-base);
    --pst-color-link: var(--pst-color-primary);
    --pst-color-link-hover: var(--pst-color-secondary);
    --pst-color-table-outer-border: var(--pst-color-surface);
    --pst-color-table-heading-bg: var(--pst-color-surface);
    --pst-color-table-row-zebra-high-bg: var(--pst-color-on-background);
    --pst-color-table-row-zebra-low-bg: var(--pst-color-surface);
  }

  // adapt to light/dark-specific content
  @if $mode == "light" {
    .only-dark,
    .only-dark ~ figcaption {
      display: none !important;
    }
  } @else {
    .only-light,
    .only-light ~ figcaption {
      display: none !important;
    }

    /* Adjust images in dark mode (unless they have class .only-dark or
     * .dark-light, in which case assume they're already optimized for dark
     * mode).
     */
    img:not(.only-dark, .dark-light) {
      filter: brightness(0.8) contrast(1.2);
    }

    /* Give images a light background in dark mode in case they have
    *  transparency and black text (unless they have class .only-dark or .dark-light, in
    *  which case assume they're already optimized for dark mode).
    */
    .bd-content img:not(.only-dark, .dark-light) {
      background-color: rgb(255 255 255);
      border-radius: 0.25rem;
    }

    // MathJax SVG outputs should be filled to same color as text.
    .MathJax_SVG * {
      fill: var(--pst-color-text-base);
    }
  }
}

/* Defaults to light mode if data-theme is not set */
html:not([data-theme]) {
  @include theme-colors("light");
}

/* NOTE: @each {...} is like a for-loop
 * https://sass-lang.com/documentation/at-rules/control/each
 */
@each $mode in (light, dark) {
  html[data-theme="#{$mode}"] {
    @include theme-colors($mode);

    color-scheme: $mode;
  }
}

// assign classes too, for runtime use of theme colors
@each $col-name, $definition in $pst-semantic-colors {
  .pst-color-#{$col-name} {
    color: var(--pst-color-#{$col-name});
  }
}
